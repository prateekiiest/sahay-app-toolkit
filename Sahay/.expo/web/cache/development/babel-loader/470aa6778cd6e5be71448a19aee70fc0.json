{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _reactNavigation = require(\"react-navigation\");\n\nvar DrawerActions = _interopRequireWildcard(require(\"./DrawerActions\"));\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction withDefaultValue(obj, key, defaultValue) {\n  if (obj.hasOwnProperty(key) && typeof obj[key] !== 'undefined') {\n    return obj;\n  }\n\n  obj[key] = defaultValue;\n  return obj;\n}\n\nvar getActiveRouteKey = function getActiveRouteKey(route) {\n  if (route.routes && typeof route.index === 'number' && route.routes[route.index]) {\n    return getActiveRouteKey(route.routes[route.index]);\n  }\n\n  return route.key;\n};\n\nvar _default = function _default(routeConfigs) {\n  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  config = (0, _extends2.default)({}, config);\n  config = withDefaultValue(config, 'resetOnBlur', config.unmountInactiveRoutes ? true : !!config.resetOnBlur);\n  config = withDefaultValue(config, 'backBehavior', 'initialRoute');\n  var switchRouter = (0, _reactNavigation.SwitchRouter)(routeConfigs, config);\n  return (0, _extends2.default)({}, switchRouter, {\n    getActionCreators: function getActionCreators(route, navStateKey) {\n      return (0, _extends2.default)({\n        openDrawer: function openDrawer() {\n          return DrawerActions.openDrawer({\n            key: navStateKey\n          });\n        },\n        closeDrawer: function closeDrawer() {\n          return DrawerActions.closeDrawer({\n            key: navStateKey\n          });\n        },\n        toggleDrawer: function toggleDrawer() {\n          return DrawerActions.toggleDrawer({\n            key: navStateKey\n          });\n        }\n      }, switchRouter.getActionCreators(route, navStateKey));\n    },\n    getStateForAction: function getStateForAction(action, state) {\n      if (!state) {\n        return (0, _extends2.default)({}, switchRouter.getStateForAction(action, undefined), {\n          isDrawerOpen: false\n        });\n      }\n\n      var isRouterTargeted = action.key == null || action.key === state.key;\n\n      if (isRouterTargeted) {\n        if (action.type === DrawerActions.CLOSE_DRAWER || action.type === _reactNavigation.NavigationActions.BACK && state.isDrawerOpen) {\n          return (0, _extends2.default)({}, state, {\n            isDrawerOpen: false\n          });\n        }\n\n        if (action.type === DrawerActions.OPEN_DRAWER) {\n          return (0, _extends2.default)({}, state, {\n            isDrawerOpen: true\n          });\n        }\n\n        if (action.type === DrawerActions.TOGGLE_DRAWER) {\n          return (0, _extends2.default)({}, state, {\n            isDrawerOpen: !state.isDrawerOpen\n          });\n        }\n      }\n\n      var switchedState = switchRouter.getStateForAction(action, state);\n\n      if (switchedState === null) {\n        return null;\n      }\n\n      if (switchedState !== state) {\n        if (getActiveRouteKey(switchedState) !== getActiveRouteKey(state) && state.isDrawerOpen) {\n          return (0, _extends2.default)({}, switchedState, {\n            isDrawerOpen: false\n          });\n        }\n\n        return switchedState;\n      }\n\n      return state;\n    }\n  });\n};\n\nexports.default = _default;","map":{"version":3,"sources":["DrawerRouter.tsx"],"names":["obj","getActiveRouteKey","route","config","withDefaultValue","switchRouter","SwitchRouter","getActionCreators","openDrawer","key","navStateKey","closeDrawer","toggleDrawer","getStateForAction","isDrawerOpen","isRouterTargeted","action","state","DrawerActions","NavigationActions","switchedState"],"mappings":"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","sourcesContent":["import {\n  SwitchRouter,\n  NavigationActions,\n  NavigationAction,\n  NavigationRoute,\n  NavigationRouteConfigMap,\n} from 'react-navigation';\nimport * as DrawerActions from './DrawerActions';\n\ntype State = NavigationRoute & {\n  isDrawerOpen?: any;\n};\n\nfunction withDefaultValue(obj: object, key: string, defaultValue: any): any {\n  // @ts-ignore\n  if (obj.hasOwnProperty(key) && typeof obj[key] !== 'undefined') {\n    return obj;\n  }\n\n  // @ts-ignore\n  obj[key] = defaultValue;\n  return obj;\n}\n\nconst getActiveRouteKey = (route: NavigationRoute): string => {\n  if (\n    route.routes &&\n    typeof route.index === 'number' &&\n    route.routes[route.index]\n  ) {\n    return getActiveRouteKey(route.routes[route.index]);\n  }\n\n  return route.key;\n};\n\nexport default (\n  routeConfigs: NavigationRouteConfigMap<any, any>,\n  config: {\n    unmountInactiveRoutes?: boolean;\n    resetOnBlur?: boolean;\n    initialRouteName?: string;\n  } = {}\n) => {\n  config = { ...config };\n  config = withDefaultValue(\n    config,\n    'resetOnBlur',\n    config.unmountInactiveRoutes ? true : !!config.resetOnBlur\n  );\n  config = withDefaultValue(config, 'backBehavior', 'initialRoute');\n\n  const switchRouter = SwitchRouter(routeConfigs, config);\n\n  return {\n    ...switchRouter,\n\n    getActionCreators(route: NavigationRoute, navStateKey: string) {\n      return {\n        openDrawer: () => DrawerActions.openDrawer({ key: navStateKey }),\n        closeDrawer: () => DrawerActions.closeDrawer({ key: navStateKey }),\n        toggleDrawer: () => DrawerActions.toggleDrawer({ key: navStateKey }),\n        ...switchRouter.getActionCreators(route, navStateKey),\n      };\n    },\n\n    getStateForAction(action: NavigationAction, state?: State) {\n      // Set up the initial state if needed\n      if (!state) {\n        return {\n          ...switchRouter.getStateForAction(action, undefined),\n          isDrawerOpen: false,\n        };\n      }\n\n      const isRouterTargeted = action.key == null || action.key === state.key;\n\n      if (isRouterTargeted) {\n        // Only handle actions that are meant for this drawer, as specified by action.key.\n        if (\n          action.type === DrawerActions.CLOSE_DRAWER ||\n          (action.type === NavigationActions.BACK && state.isDrawerOpen)\n        ) {\n          return {\n            ...state,\n            isDrawerOpen: false,\n          };\n        }\n\n        if (action.type === DrawerActions.OPEN_DRAWER) {\n          return {\n            ...state,\n            isDrawerOpen: true,\n          };\n        }\n\n        if (action.type === DrawerActions.TOGGLE_DRAWER) {\n          return {\n            ...state,\n            isDrawerOpen: !state.isDrawerOpen,\n          };\n        }\n      }\n\n      // Fall back on switch router for screen switching logic, and handling of child routers\n      const switchedState = switchRouter.getStateForAction(action, state);\n\n      if (switchedState === null) {\n        // The switch router or a child router is attempting to swallow this action. We return null to allow this.\n        return null;\n      }\n\n      // Has the switch router changed the state?\n      if (switchedState !== state) {\n        // If any navigation has happened, and the drawer is maybe open, make sure to close it\n        if (\n          getActiveRouteKey(switchedState) !== getActiveRouteKey(state) &&\n          state.isDrawerOpen\n        ) {\n          return {\n            ...switchedState,\n            isDrawerOpen: false,\n          };\n        }\n\n        // At this point, return the state as defined by the switch router.\n        // The active route key hasn't changed, so this most likely means that a child router has returned\n        // a new state like a param change, but the same key is still active and the drawer will remain open\n        return switchedState;\n      }\n\n      return state;\n    },\n  };\n};\n"]},"metadata":{},"sourceType":"script"}